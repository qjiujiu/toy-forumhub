## 论坛数据表

数据表分为 4 个部分： **用户，帖子，评论，点赞**。所有数据表都包含系统主键（自增，物理主键）和业务主键（uuid，候选主键）

用户在登录的前提下才可以发帖子，评论与点赞。下面先讲用户表

### User

用户表分为3个部分，用户基本信息表 users，用户关注表 follows，用户统计信息表 user_statistics

#### users

用户表 users **必填字段**：用户名 `username` （不唯一），登录密码 ` password`（密文），手机号码  `phone` （唯一）

理论上使用第三方登录时，登录密码和手机号码字段都可为空，但是我目前不还没了解怎么实现，所以仍是必填字段

用户表中有一个 `role` 角色字段，这个论坛共包含 3 种角色：普通用户，审核员，管理员。用户注册的时候默认都是普通用户，要成为审核员或管理员账号需要管理员在数据表上更改。用户表上还有3个用户状态：正常，冻结，封禁。冻结是暂时性的，封禁是永久的，不可逆的（理论上）。用户角色和用户状态通过枚举 Enum 的方式选择。

还有一个重要字段 `deleted_at`，删除用户时通常使用**软删除**，在 `deleted_at` 字段处填入软删除的时间，用户将不对外公开。

```python
class UserRole(PyEnum):
    NORMAL_USER = 0 # 普通用户
    MODERATOR = 1   # 审核员
    ADMIN = 2       # 管理员

class UserStatus(PyEnum):
    NORMAL = 0  # 正常
    BANNED = 1  # 封禁
    FROZEN = 2  # 冻结

class User(Base):
    __tablename__ = "users"
    # 系统主键：自增
    _id = Column(Integer, primary_key=True, autoincrement=True)  # 系统主键ID，系统用，不对外暴露
    # 业务主键：UUID，唯一且不自增  
    uid = Column(String(36), unique=True, default=lambda: str(uuid.uuid4()))  # 用户的业务主键，UUID形式
    username = Column(String(100), nullable=False)  # 用户昵称
    avatar_url = Column(String(255), nullable=True)  # 用户头像
    email = Column(String(100), unique=True, nullable=True)  # 用户邮箱
    phone = Column(String(50), unique=True, nullable=False)  # 用户电话
    password = Column(String(255), nullable=False)  # 密码哈希
    role = Column(SmallInteger, default=UserRole.NORMAL_USER.value)  # 用户角色（普通用户、审核员、管理员）
    bio = Column(Text, nullable=True)  # 用户简介
    status = Column(SmallInteger, default=UserStatus.NORMAL.value) # 用户状态（0正常，1封禁，2冻结）
    last_login_at = Column(TIMESTAMP(timezone=True), default=now_utc8)  # 最后登录时间
    created_at = Column(TIMESTAMP(timezone=True), default=now_utc8)  # 创建时间
    updated_at = Column(TIMESTAMP(timezone=True), default=now_utc8, onupdate=now_utc8)  # 更新时间
    deleted_at = Column(TIMESTAMP(timezone=True), nullable=True)  # 软删除时间戳

    # 反向引用：该用户的所有帖子
    posts = relationship("Post", back_populates="author")
    # 反向引用：该用户的所有评论
    comments = relationship("Comment", back_populates="author")
    # 反向引用：该用户的所有点赞记录
    likes = relationship("Like", back_populates="user")
    # 单向引用：该用户的统计信息（关注数和粉丝数）
    userstats = relationship("UserStats", uselist=False, cascade="all, delete-orphan")
    # 我关注的人（关注者是我 -> 多个 Follow 记录）
    followings = relationship("Follow", foreign_keys="Follow.user_id", back_populates="user")
    # 我的粉丝（被关注者是我 -> 多个 Follow 记录）
    followers = relationship("Follow", foreign_keys="Follow.followed_user_id", back_populates="followed_user")
```

用户表可以拓展关注和粉丝两个列表

#### follows

关注表主要用来记录某个用户在何时关注另外一个用户，必填字段：关注者ID`user_id`，被关注者ID `followed_user_id`

```python
class Follow(Base):
    __tablename__ = "follows"
    
    _id = Column(Integer, primary_key=True, autoincrement=True)                     # 系统主键（自增）
    user_id = Column(String(36), ForeignKey("users.uid"), nullable=False)           # 关注者ID
    followed_user_id = Column(String(36), ForeignKey("users.uid"), nullable=False)  # 被关注者ID
    
    created_at = Column(TIMESTAMP(timezone=True), default=now_utc8)  # 记录创建时间
    deleted_at = Column(TIMESTAMP(timezone=True), nullable=True)     # 软删除时间戳（用于取消关注）

    # 反向引用：该关注记录的关注者
    user = relationship("User", foreign_keys=[user_id], back_populates="followers")
    # 反向引用：该关注记录的被关注者
    followed_user = relationship("User", foreign_keys=[followed_user_id], back_populates="followers")
```



#### user_statistics

由于关注数和粉丝数是一个频繁更新的字段，所以这里额外设计了一个用户统计数据表用来存放这两个字段，后续这个表还可拓展其他频繁更新的用户字段。

必填字段：`user_id`

因为用户的关注列表和粉丝列表涉及关注数和粉丝数的更新，所以业务上规定不允许直接硬删除关注表中的记录，必须先要软删除，软删除逻辑中包含更新关注数和粉丝数，之后才可以硬删除。（硬删除待实现）

```python
class UserStatistics(Base):
    __tablename__ = "user_statistics"

    id = Column(Integer, primary_key=True, autoincrement=True) # 系统主键（自增）
    user_id = Column(String(36), ForeignKey("users.uid"), nullable=False) # 用户ID（外键，关联用户表）
    following_count = Column(Integer, default=0) # 用户关注数
    followers_count = Column(Integer, default=0)  # 用户粉丝数
    # 更新时间
    updated_at = Column(TIMESTAMP, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
```



### Post

**遵循动态表和静态表结合的设计理念**，帖子表包含 3 张表：论坛帖子 posts 和帖子内容表 post_content 以及帖子统计数据表 post_stats

- posts 是静态表，主要存储帖子的基本信息和状态，比如审核状态，发布状态，帖子可见性等等。
- post_content 是静态表，主要存储那些大文本但更新频率较低的内容，如帖子标题 `title`、帖子内容 `content`
- post_stats 是动态表，主要存储那些频繁变动的数据，比如帖子的点赞数 `like_count`，评论数 `comment_count`

#### posts

帖子表中**必填字段**：`author_id` 作者id (FK$\rightarrow$users.uid)，`publish_status` 发布状态（直接发布或存草稿）。

帖子有3个状态 `visibility`：公开可见，仅作者可见，草稿；有3个审核状态 `review_status`：待审，通过，拒绝。这些同样是通过枚举Enum 的方式实现的。

```python
 # 帖子可见性
class PostVisibility(IntEnum):
    PUBLIC = 0        # 所有人可见
    AUTHOR_ONLY = 1   # 仅作者可见
    # 以后可以扩展：
    # FOLLOWERS_ONLY = 2
    # MUTUAL_ONLY = 3

# 帖子的发布状态
class PostPublishStatus(IntEnum):
    DRAFT = 0         # 草稿（未发布）
    PUBLISHED = 1     # 已发布

# 帖子审核状态
class PostReviewStatus(IntEnum):
    PENDING = 0   # 待审
    APPROVED = 1  # 通过
    REJECTED = 2  # 拒绝

class Post(Base):
    __tablename__ = "posts"
    _id = Column(Integer, primary_key=True, autoincrement=True)  # 系统主键ID，系统用，不对外暴露
    pid = Column(String(36), unique=True, default=lambda: str(uuid.uuid4()))  # 用户的业务主键（UUID形式）

    author_id = Column(String(36), ForeignKey("users.uid"), nullable=False)        # 帖子作者 ID
    visibility = Column(SmallInteger, default=PostVisibility.PUBLIC.value)         # 可见性（0:公开, 1:仅作者）
    # 发布状态（0:草稿, 1:发布）
    publish_status = Column(SmallInteger, default=PostPublishStatus.PUBLISHED.value)  
    # 审核状态（0:待审, 1:通过, 2:拒绝）
    review_status = Column(SmallInteger, default=PostReviewStatus.PENDING.value)   
    reviewed_at = Column(TIMESTAMP(timezone=True), nullable=True)  # 审核时间
    deleted_at = Column(TIMESTAMP(timezone=True), nullable=True)   # 软删除时间戳

    # 反向引用：该帖子的作者
    author = relationship("User", back_populates="posts")
    # 双向引用：该帖子的评论
    comments = relationship("Comment", back_populates="post")
    # 单向引用：该帖子的内容
    post_content = relationship("PostContent", uselist=False, cascade="all, delete-orphan")
    # 单向引用：该帖子的统计信息
    post_stats = relationship("PostStats", uselist=False, cascade="all, delete-orphan") 
    # 还是使用 relationship 关联点赞表与帖子表之间的数据，为了方便查询哪些用户点赞这篇帖子
    likes = relationship("Like", primaryjoin="and_(Like.target_id == Post.pid, Like.target_type == 0)", foreign_keys="Like.target_id", viewonly=True)
```



#### post_contents

帖子内容表中**必填字段**：帖子标题 `title`，帖子内容 `content`，帖子ID `post_id` (FK -> posts.pid)。先插入posts表即可获取`post_id`

业务主键是 `pcid`

```python
class PostContent(Base):    
    __tablename__ = "post_contents"
    
    id = Column(Integer, primary_key=True, autoincrement=True)   # 系统主键（自增）
    pcid = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4())) # 业务主键
    post_id =  Column(String(36), ForeignKey("posts.pid"), nullable=False)                     # 帖子ID
    title = Column(String(255), nullable=False)                  # 帖子标题
    content = Column(Text, nullable=False)                       # 帖子内容
    created_at = Column(TIMESTAMP(timezone=True), default=now_utc8)                     # 创建时间
    updated_at = Column(TIMESTAMP(timezone=True), default=now_utc8, onupdate=now_utc8)  # 更新时间
```

 

#### post_stats

帖子统计数据表中**必填字段**：帖子ID `post_id` (FK -> posts.pid)

注意到这里有点赞数和评论数，所以点赞表和评论表的记录不可以乱删，必须先软删除，再硬删除。软删除的逻辑包含更新点赞数和评论数

```PYTHON
class PostStats(Base):
    __tablename__ = "post_stats"

    _id = Column(Integer, primary_key=True, autoincrement=True) # 系统主键（自增）
    psid = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4())) # 业务主键   
    post_id = Column(String(36), ForeignKey("posts.pid"), nullable=False) # 帖子 ID
    like_count = Column(Integer, default=0)                               # 帖子点赞数
    comment_count = Column(Integer, default=0)                            # 帖子总评论数
    # 后续可扩展收藏数，转发数
```

综上所述，创建一篇帖子的请求体必填字段：`author_id`，`publish_status`，`title`，`content`



### Comment

同样遵循动态表和静态表结合的设计理念，评论功能共包含 2 张表：

- 评论表 comments，**存储每一条评论的基本信息**以及统计信息，例如评论的父评论 `parent_id`，评论的评论数与点赞数等。

- 评论内容表 comment_contents，**只存储评论的内容**。

由于评论内容是大字段，且相对独立、很少修改，因此独立设计这评论内容表作为静态表。评论表为动态表。

#### comments

**评论区表记录的是每一条评论信息，不包含具体的评论内容**

评论表中**必填字段**：评论作者`author_id`(FK -> users.uid)，帖子id `post_id` (FK$\rightarrow$​posts.pid)，以及该评论的父评论 `parent_id`，根评论 `root_id`。提及到评论的父评论和跟评论，这里补充分级评论设计规则：

- 一级：`parent_id is NULL` 且 `root_id = cid`
- 二级：`parent_id = root_id`
- 三级及以上：`parent_id != root_id` 且 `parent_id is not NULL`

这样的好处是任何楼中楼对话，都可以通过以下命令一次性把整组对话拉出来

```sql
SELECT * FROM comments WHERE root_id = :root_cid
```

评论表中还有字段 `comment_count` 是**评论的评论数**，这条评论新增一条回复要在这个字段加 1

字段 `like_count` 是**评论的点赞数**，点赞功能在点赞表中详细介绍。

评论表有 2个评论状态 `status`：正常，折叠；**低质量评论（例如大篇幅@他人，无意义内容）可以折叠起来不直接显示给用户**。

3个审核状态 `review_status`：待审，通过，拒绝。同样地，使用枚举 Enum 实现。评论使用审核用户没有办法感受到实时性，所以这里**采用的审核制度是先发后审**：用户评论直接展示，后台异步审核，检测到违规在前端折叠或删除。后续可以采用人工加机器结合的方式审。

删除评论采用的是**软删除**方式，字段 `deleted_at` 非空时表示评论以及被软删除。

- 在删除一级评论的时候，理论上是删除所有回复一级评论子评论，但是为了避免**写放大**，所以一般不会直接删除子评论，只是将一级评论的 `deleted_at` 字段设为非空。**子评论消失看不见（这与查询逻辑有关）**。
- 删除子评论时，也是同样设置 `deleted_at` 字段设为非空，但是子评论的所有子评论不会消失。

在页面展示的时候只会有一级评论，以及一级评论的评论数和点赞数。需要查看二级或更多级评论需要点击新的查询接口。实现起来很简单，就是把同一个 root_id 的所有评论按时间顺序返回，业务上还是实现了查看楼中楼对话组的功能，详情看代码。

```python
# 评论显示状态
class CommentStatus(IntEnum):
    NORMAL = 0    # 正常展示
    FOLDED = 1    # 折叠（低质量/被投票降低等）

# 审核状态
class ReviewStatus(IntEnum):
    PENDING  = 0  # 待审
    APPROVED = 1  # 通过
    REJECTED = 2  # 拒绝
    
class Comment(Base):
    __tablename__ = "comments"
    
    _id = Column(Integer, primary_key=True, autoincrement=True)                               # 系统主键
    cid = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))  # 业务主键
    post_id = Column(String(36), ForeignKey("posts.pid"), nullable=False)   # 评论ID
    comment_count = Column(Integer, default=0)                              # 评论数
    author_id = Column(String(36), ForeignKey("users.uid"), nullable=False) # 评论作者 ID
    parent_id = Column(String(36), nullable=True)                           # 父评论 ID（可为空）
    root_id = Column(String(36), nullable=True)                             # 顶级评论 ID
    like_count = Column(Integer, default=0, nullable=False)                 # 点赞数  
    # 评论状态（正常/折叠）
    status = Column(SmallInteger, default=CommentStatus.NORMAL.value, nullable=False) 
    # 审核状态（待审/通过/拒绝）
    review_status = Column(SmallInteger, default=ReviewStatus.PENDING.value, nullable=False)    
    reviewed_at = Column(TIMESTAMP(timezone=True), nullable=True)    # 审核时间
    created_at = Column(TIMESTAMP(timezone=True), default=now_utc8)  # 创建时间
    deleted_at = Column(TIMESTAMP(timezone=True), nullable=True)     # 软删除时间戳

    # 反向引用：该评论区的作者
    author = relationship("User", back_populates="comments")
    # 反向引用：该帖子的评论总览信息（包含帖子ID），可能希望通过评论跳转帖子
    post = relationship("Post", back_populates="comments")
    # 单向引用：该评论区的评论内容
    comment_content = relationship("CommentContent", uselist=False, cascade="all, delete-orphan")
    # 单向引用：该评论区的点赞
    likes = relationship("Like", primaryjoin="and_(Like.target_id == Comment.cid, Like.target_type == 1)", foreign_keys="Like.target_id", viewonly=True,)
```



#### comment_contents

**评论内容表存储的是评论的具体内容**，**必填字段**：评论内容 `content`

```python
class CommentContent(Base):   
    __tablename__ = "comment_contents"
    
    _id = Column(Integer, primary_key=True, autoincrement=True)                               # 系统主键
    ccid = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4())) # 业务主键
    
    comment_id = Column(String(36), ForeignKey("comments.cid"), nullable=False)  # 评论区 ID
    content = Column(Text, nullable=False)                                       # 评论内容
    created_at = Column(TIMESTAMP(timezone=True), default=now_utc8)                     # 创建时间
    updated_at = Column(TIMESTAMP(timezone=True), default=now_utc8, onupdate=now_utc8)  # 更新时间
```

综上所述，插入一条评论的请求体必填字段为：`post_id`，`author_id`，`parent_id`，`root_id`，`content`




### Like

点赞主要用来**记录某个用户点赞帖子或评论的记录**，同时还可以用来**约束每个用户对一个帖子或评论，只能点一个赞**。

**必填字段**：用户 ID `user_id`，点赞目标类型（0: 帖子, 1: 评论）`target_type` ，点赞目标帖子或评论 ID `target_id`

用户表，评论表，帖子表都需要关联点赞表的数据，虽然这些表本身只显示点赞数，但是可以方便查询是用户点赞了哪篇帖子或评论，又或是，哪些用户点赞这篇帖子评论。

```python
# 点赞目标类型
class LikeTargetType(PyEnum):
    POST = 0  # 帖子
    COMMENT = 1  # 评论

class Like(Base):
    __tablename__ = "likes"
   
    _id = Column(Integer, primary_key=True, autoincrement=True)               # 系统主键（内部使用，不对外暴露）
    lid = Column(String(36), unique=True, default=lambda: str(uuid.uuid4())) # 业务主键
    user_id = Column(String(36), ForeignKey("users.uid"), nullable=False)  # 用户 ID
    target_type = Column(SmallInteger, nullable=False)                     # 点赞目标类型（0: 帖子, 1: 评论）
    target_id = Column(String(36), nullable=False)                         # 点赞目标 ID（帖子或评论 ID）
    created_at = Column(TIMESTAMP, default=datetime.datetime.utcnow)       # 点赞时间
    updated_at = Column(TIMESTAMP(timezone=True), default=now_utc8, onupdate=now_utc8)  # 更新时间
    deleted_at = Column(TIMESTAMP, nullable=True)                          # 软删除时间戳
```

点赞表是一个“多态关联”（一个字段指向两个表），这时候需要显示标记哪一列是“外键那一边，比如下面的代码，用 `foreign()` 把 `Like.target_id` 标记为“外键侧”

```python
# 反向引用：该点赞的帖子（如果是帖子点赞）
post = relationship("Post", back_populates="likes", uselist=False, primaryjoin="and_(foreign(Like.target_id) == Post.pid, Like.target_type == 0)", viewonly=True)
# 反向引用：该点赞的评论区（如果是评论区点赞）
comment = relationship("Comment", back_populates="likes", uselist=False, primaryjoin="and_(foreign(Like.target_id) == Comment.cid, Like.target_type == 1)", viewonly=True)    
```

这样写的好处是关系自动填充，不用手动声明，代码上更简洁。

但是在实际业务上可能会更加推荐把上面的多态关联去掉，不在模型上声明多态关系，而是在数据层根据 target_type 主动查询目标表，在业务层或数据层填充响应体。



### 数据表关联图

![image-20251203201036666](C:\Users\qiuji\Desktop\forum_system\img\image-20251203201036666.png)
