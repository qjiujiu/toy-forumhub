## 论坛数据表

数据表分为 4 个部分： **用户，帖子，评论，点赞**。所有数据表都包含系统主键（自增，物理主键）和业务主键（uuid，候选主键）

用户在登录的前提下才可以发帖子，评论与点赞。下面先讲用户表

### User

用户表分为3个部分，用户基本信息表 users，用户关注表 follows，用户统计信息表 user_statistics

#### users

用户表 users **必填字段**：用户名 `username` （不唯一），登录密码 ` password`（密文），手机号码  `phone` （唯一）

理论上使用第三方登录时，登录密码和手机号码字段都可为空，但是我不懂怎么实现，目前仍是必填字段

用户表中有一个 `role` 角色字段，这个论坛共包含 3 种角色：普通用户，审核员，管理员。用户注册的时候默认都是普通用户，要成为审核员或管理员账号需要管理员在数据表上更改。用户表上还有3个用户状态：正常，冻结，封禁。冻结是暂时性的，封禁是永久的，不可逆的（理论上）。用户角色和用户状态通过枚举 Enum 的方式选择。

还有一个重要字段 `deleted_at`，删除用户时通常使用**软删除**，在 `deleted_at` 字段处填入软删除的时间，用户将不对外公开。

```python
class UserRole(PyEnum):
    NORMAL_USER = 0 # 普通用户
    MODERATOR = 1   # 审核员
    ADMIN = 2       # 管理员

class UserStatus(PyEnum):
    NORMAL = 0  # 正常
    BANNED = 1  # 封禁
    FROZEN = 2  # 冻结

class User(Base):
     __tablename__ = "users"
        
    id = Column(Integer, primary_key=True, autoincrement=True)  # 系统主键ID，系统用，不对外暴露
    uid = Column(String(36), unique=True, default=lambda: str(uuid.uuid4()))  # 用户的业务主键，UUID形式
    username = Column(String(100), nullable=False)              # 用户昵称
    avatar_url = Column(String(255), nullable=True)             # 用户头像
    email = Column(String(100), unique=True, nullable=True)     # 用户邮箱
    phone = Column(String(50), unique=True, nullable=False)     # 用户电话
    password = Column(String(255), nullable=True)               # 密码哈希
    role = Column(SAEnum(UserRole), default=UserRole.NORMAL_USER)  # 用户角色（普通用户、审核员、管理员）
    bio = Column(Text, nullable=True)                              # 用户简介
    status = Column(SAEnum(UserStatus), default=UserStatus.NORMAL) # 用户状态（0正常，1封禁，2冻结）
    last_login_at = Column(TIMESTAMP, default=datetime.datetime.utcnow)  # 最后登录时间
    created_at = Column(TIMESTAMP, default=datetime.datetime.utcnow)     # 创建时间
    # 更新时间
    updated_at = Column(TIMESTAMP, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)  
    deleted_at = Column(TIMESTAMP, nullable=True)  # 软删除时间戳

    # 反向引用：该用户的所有帖子
    posts = relationship("Post", back_populates="author")
    # 反向引用：该用户的所有评论
    comment_sections = relationship("CommentSection", back_populates="author")
    # 单向引用：该用户的所有点赞记录
    likes = relationship("Like")
    # 单向引用：该用户的统计信息（关注数和粉丝数）
    statistics = relationship("UserStatistics", uselist=False)
```

用户表可以拓展关注和粉丝两个列表

#### follows

关注表主要用来记录某个用户在何时关注另外一个用户，必填字段：关注者ID`user_id`，被关注者ID `followed_user_id`

```python
class Follow(Base):
    __tablename__ = "follows"

    id = Column(Integer, primary_key=True, autoincrement=True) # 系统主键（自增）
    user_id = Column(String(36), ForeignKey("users.uid"), nullable=False) # 关注者ID
    followed_user_id = Column(String(36), ForeignKey("users.uid"), nullable=False) # 被关注者ID
    created_at = Column(TIMESTAMP, default=datetime.datetime.utcnow) # 记录创建时间
    deleted_at = Column(TIMESTAMP, nullable=True) # 软删除时间戳（用于取消关注）

    # 单向引用：该关注记录的关注者
    user = relationship("User", foreign_keys=[user_id], cascade="all, delete-orphan")
    # 单向引用：该关注记录的被关注者
    followed_user = relationship("User", foreign_keys=[followed_user_id], cascade="all, delete-orphan")

    __table_args__ = (
        # 联合唯一约束：确保每个用户只能关注一次某个用户
        UniqueConstraint("user_id", "followed_user_id", name="uq_user_follow"),
        # 索引：加速查询
        Index("idx_follow_user", "user_id"),
        Index("idx_followed_user", "followed_user_id"),
    )
```



#### user_statistics

由于关注数和粉丝数是一个频繁更新的字段，所以这里额外设计了一个用户统计数据表用来存放这两个字段，后续这个表还可拓展其他频繁更新的用户字段。

必填字段：

```python
class UserStatistics(Base):
    __tablename__ = "user_statistics"

    id = Column(Integer, primary_key=True, autoincrement=True) # 系统主键（自增）
    user_id = Column(String(36), ForeignKey("users.uid"), nullable=False) # 用户ID（外键，关联用户表）
    following_count = Column(Integer, default=0) # 用户关注数
    followers_count = Column(Integer, default=0)  # 用户粉丝数
    # 更新时间
    updated_at = Column(TIMESTAMP, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)

    __table_args__ = (
        # 确保每个用户只有一条记录
        UniqueConstraint("user_id", name="unique_user_statistics"),
        # 索引：加速查询
        Index("idx_user_statistics_user_id", "user_id"),
    )
```



### Post

**遵循动态表和静态表结合的设计理念**，帖子表包含 2 张表：论坛帖子 posts 和帖子内容表 post_content，它们是一对一的关系

- posts 是动态表，主要存储那些频繁变动的数据，比如帖子的点赞数 `like_count`
- post_content 是静态表，主要存储那些大文本但更新频率较低的内容，如帖子标题 `title`、帖子内容 `content`

#### posts

帖子表中**必填字段**：`author_id` 作者id，`postcontent_id` 帖子内容 id。这两个字段分别关联用户表 users 中的 `uid` 和帖子内容表中的 `pcid` 。

每个帖子都有单独的评论区，所以用字段 `comment_id` ，关联评论表中的 `cid`。这个字段不是必填，第一条评论出现时再填入。

帖子有3个状态 `visibility`：公开可见，仅作者可见，草稿；有3个审核状态 `review_status`：待审，通过，拒绝。这些同样是通过枚举Enum 的方式实现的。

```python
# 帖子可见性
class PostVisibility(PyEnum):
    PUBLIC = 0  # 公开
    AUTHOR_ONLY = 1  # 仅作者
    DRAFT = 2  # 草稿
    
# 帖子审核状态
class PostReviewStatus(PyEnum):
    PENDING = 0  # 待审
    APPROVED = 1  # 通过
    REJECTED = 2  # 拒绝

class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True, autoincrement=True)               # 系统主键ID，系统用，不对外暴露
    pid = Column(String(36), unique=True, default=lambda: str(uuid.uuid4())) # 用户的业务主键（UUID形式）
    author_id = Column(String(36), ForeignKey("users.uid"), nullable=False)  # 帖子作者 ID
    # 可见性（0:公开, 1:仅作者, 2:草稿）
    visibility = Column(SAEnum(PostVisibility), default=PostVisibility.PUBLIC)  
    # 审核状态（0:待审, 1:通过, 2:拒绝）
    review_status = Column(SAEnum(PostReviewStatus), default=PostReviewStatus.PENDING)  
    reviewed_at = Column(TIMESTAMP, nullable=True)           # 审核时间
    like_count = Column(Integer, default=0, nullable=False)  # 点赞数
    deleted_at = Column(TIMESTAMP, nullable=True)            # 软删除时间戳
    # 关联静态内容表（post_contents id）
    postcontent_id = Column(String(36), ForeignKey("post_contents.pcid"), nullable=False)
    # 关联评论表（comment_id 评论表id）
    comment_id = Column(String(36), ForeignKey("comments.cid"), nullable=True)

    # 反向引用：该帖子的作者
    author = relationship("User", back_populates="posts")
    # 单向引用：该帖子的内容
    post_content = relationship("PostContent")
    # 单向引用：该帖子的评论
    comment = relationship("Comment")
    # 单向引用：该帖子的点赞
    likes = relationship("Like")

    __table_args__ = (
        # 保证业务主键 pid 唯一
        UniqueConstraint('pid', name='unique_pid'),
        # 索引与上面的 SQL 一致（让 ORM 自动建索引）
        Index("idx_posts_author_id", "author_id"),
        Index("idx_posts_visibility_review_status", "visibility", "review_status"),
        Index("idx_posts_author_visibility", "author_id", "visibility"),
    )
```



#### post_contents

帖子内容表中**必填字段**：帖子标题 `title`，帖子内容 `content`

业务主键是 `pcid`，它是前面提到帖子表中 `postcontent_id`  的关联外键


 综上所述，创建一篇帖子的请求体必填字段：`author_id`，`postcontent_id`，`title`，`content`

```python
class PostContent(Base):    
    __tablename__ = "post_contents"

    id = Column(Integer, primary_key=True, autoincrement=True)   # 系统主键（自增）
    # 业务主键（UUID，对外使用）
    pcid = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4())) 
    title = Column(String(255), nullable=False)                  # 帖子标题
    content = Column(Text, nullable=False)                       # 帖子内容
```



### Comment

同样遵循动态表和静态表结合的设计理念，评论功能共包含 3 张表：

首先是评论表 comments，**存储帖子评论的总览信息**，包含帖子 id，帖子对应的评论区 id，以及该帖子的总评论数。

其次是评论区表 comment_sections，**存储每一条评论信息**，但不包含具体的评论内容。例如这条评论的作者，父评论 id，根评论 id，点赞数等等。

最后是评论内容表 comment_contents，**只存储评论的内容**。

由于评论内容是大字段，且相对独立、很少修改，因此独立设计这评论内容表作为静态表。评论表与评论区表为动态表。

#### comments

评论表中**必填字段**：帖子id `post_id`，评论区 id `commentsection_id`。这两个字段分别关联帖子表 posts 中的 `pid` 和 评论区表中的 `csid`

字段 `count` 是**帖子的总评论数**，这篇帖子添加一条评论要在这个字段加 1

业务主键是 `cid`，它是前面提到帖子表中 `comment_id` 的关联外键。

**每一篇帖子都有对应的评论区**，所以用字段 `commentsection_id` 关联评论区表中的 `csid` （评论区表的业务主键）

```python
class Comment(Base):
    __tablename__ = "comments"

    id = Column(Integer, primary_key=True, autoincrement=True)            # 系统主键（自增）
    # 业务主键（UUID，对外使用）
    cid = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4())) 
    post_id = Column(String(36), ForeignKey("posts.pid"), nullable=False) # 帖子 ID
    count = Column(Integer, default=0)                                    # 帖子总评论数    
    # 评论区 ID，关联评论区表
    commentsection_id = Column(String(36), ForeignKey("comment_sections.csid"), nullable=False)
    # 反向引用：该评论区的评论
    comment_sections = relationship("CommentSection", back_populates="comment")

    __table_args__ = (
        UniqueConstraint('cid', name='unique_cid'),
        Index("idx_comments_post", "post_id"),
        Index("idx_comments_commentsection", "commentsection_id"),
    )
```



#### comment_sections

**评论区表记录的是每一条评论信息，不包含具体的评论内容**

评论区表中**必填字段**：发布评论的作者id `author_id`，该评论的父评论 `parent_id`，根评论 `root_id`。其中，作者id `author_id` 和父评论 `parent_id` 分别关联用户表 users 中的 `uid` 以及评论表 comments 中的 `cid`

字段 `count` 是该**评论的总评论数**，这条评论添加一条子评论就要在这个字段加 1

字段 `like_count` 是**该评论的点赞数**。

评论区表有 2个评论状态 `status`：正常，折叠；**低质量评论（例如大篇幅@他人，无意义内容）可以折叠起来不直接显示给用户**。

3个审核状态 `review_status`：待审，通过，拒绝。同样地，使用枚举 Enum 实现。评论使用审核用户没有办法感受到实时性，所以这里**采用的审核制度是先发后审**：用户评论直接展示，后台异步审核，检测到违规在前端折叠或删除。后续可以采用人工加机器结合的方式审。

业务主键是  `csid `，它是评论表中的 `commentsection_id` 关联外键

**每一条评论都有具体的评论内容**，所有用字段 `commentcontent_id` 关联评论内容表的 `ccid`（评论内容表的业务主键）

删除评论采用的是**软删除**方式，字段 `deleted_at` 非空时表示评论以及被软删除。

- 在删除一级评论的时候，理论上是删除所有回复一级评论子评论，但是为了避免**写放大**，所以一般不会直接删除子评论，只是将一级评论的 `deleted_at` 字段设为非空。
- 删除子评论时，也是同样设置 `deleted_at` 字段设为非空，但是子评论的所有子评论不会消失。

在页面展示的时候只有两级评论，一级评论是根评论（直接回复帖子的评论），二级评论是回复评论的评论。

通常一级评论的 `root_id` 为空（这可以作为查询一级评论的依据），其子评论的 `root_id` 为一级评论的 `cid`。

- 用户查询评论的时候只返回一级评论（分页），查看评论的评论的时候返回一级评论的所有评论（分页）。

当一级评论 `root_id` 为空而且 `deleted_at` 非空时，意味着一级评论已经被删除了，这时候不再返回一级评论及其所有子评论。 换句话说，在查询帖子评论的时候，只返回 `root_id `为空，而且 `deleted_at` 为空时的一级评论。在可公开的一级评论中才可以查看其所有的二级评论。

```python
# 评论显示状态
class CommentStatus(PyEnum):
    NORMAL = 0    # 正常展示
    FOLDED = 1    # 折叠（低质量/被投票降低等）

# 审核状态
class ReviewStatus(PyEnum):
    PENDING  = 0  # 待审
    APPROVED = 1  # 通过
    REJECTED = 2  # 拒绝

class CommentSection(Base):
    __tablename__ = "comment_sections"

    id = Column(Integer, primary_key=True, autoincrement=True)                # 系统主键（自增）
    # 业务主键（UUID，对外使用）
    csid = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))    
    count = Column(Integer, default=0)                                        # 评论数
    author_id = Column(String(36), ForeignKey("users.uid"), nullable=False)   # 评论作者 ID
    parent_id = Column(String(36), ForeignKey("comments.cid"), nullable=True) # 父评论 ID（可为空）
    root_id = Column(String(36), nullable=False)                              # 顶级评论 ID
    like_count = Column(Integer, default=0, nullable=False)                   # 点赞数
    # 评论状态（正常/折叠）
    status = Column(SAEnum(CommentStatus), default=CommentStatus.NORMAL, nullable=False)
    # 审核状态（待审/通过/拒绝）
    review_status = Column(SAEnum(ReviewStatus), default=ReviewStatus.PENDING, nullable=False)
    reviewed_at = Column(TIMESTAMP, nullable=True)                            # 审核时间
    deleted_at = Column(TIMESTAMP, nullable=True)                             # 软删除时间戳
    # 评论内容的业务主键
    commentcontent_id = Column(String(36), ForeignKey("comment_contents.ccid"), nullable=False)

    # 反向引用：该评论区的作者
    author = relationship("User", back_populates="comment_sections")
    # 反向引用：该帖子的评论总览信息（包含帖子ID），可能希望通过评论跳转帖子
    comment = relationship("Comment", back_populates="comment_sections")
    # 单向引用：该评论区的评论内容
    comment_content = relationship("CommentContent")
    # 单向引用：该评论区的点赞
    likes = relationship("Like")

    __table_args__ = (
        UniqueConstraint('csid', name='unique_csid'),
        Index("idx_comment_sections_author", "author_id"),
        Index("idx_comment_sections_parent", "parent_id"),
        Index("idx_comment_sections_root", "root_id"),
    )
```



#### comment_contents

**评论内容表存储的是评论的具体内容**，**必填字段**：评论内容 `content`

业务主键是 `ccid`，它是前面提到评论区表中 `commentcontent_id` 的关联外键。

综上所述，插入一条评论的请求体必填字段为：`post_id`，`commentsection_id`，`author_id`，`parent_id`，`root_id`，`content`

```python
class CommentContent(Base):
    __tablename__ = "comment_contents"

    id = Column(Integer, primary_key=True, autoincrement=True)        # 系统主键（自增）
    # 业务主键（UUID，对外使用）
    ccid = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))
    content = Column(Text, nullable=False)                            # 评论内容
    created_at = Column(TIMESTAMP, default=datetime.datetime.utcnow)  # 创建时间
    # 更新时间
    updated_at = Column(TIMESTAMP, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)  
```




### Like

点赞主要用来**记录某个用户点赞帖子或评论的记录**，同时还可以用来**约束每个用户对一个帖子或评论，只能点一个赞**。

**必填字段**：用户 ID `user_id`，点赞目标类型（0: 帖子, 1: 评论）`target_type` ，点赞目标帖子或评论 ID `target_id`

TODO ：关于用户表，评论表，帖子表是否需要关联点赞表我还要再思考一下

用户表，评论表，帖子表都需要关联点赞表的数据，虽然这些表本身只显示点赞数，但是可以方便查询是用户点赞了哪篇帖子或评论，又或是，哪些用户点赞这篇帖子评论。

```python
# 点赞目标类型
class LikeTargetType(PyEnum):
    POST = 0  # 帖子
    COMMENT = 1  # 评论

class Like(Base):
    __tablename__ = "likes"
    
    id = Column(Integer, primary_key=True, autoincrement=True)            # 系统主键（内部使用，不对外暴露）
    # 业务主键（UUID，对外使用）
    lid = Column(String(36), unique=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String(36), ForeignKey("users.uid"), nullable=False) # 用户 ID
    target_type = Column(SAEnum(LikeTargetType), nullable=False)          # 点赞目标类型（0: 帖子, 1: 评论）
    target_id = Column(String(36), nullable=False)                        # 点赞目标 ID（帖子或评论 ID）
    created_at = Column(TIMESTAMP, default=datetime.datetime.utcnow)      # 点赞时间
    deleted_at = Column(TIMESTAMP, nullable=True)                         # 软删除时间戳
    
    __table_args__ = (
        # 每个用户对同一目标只能点赞一次（业务约束）
        UniqueConstraint("user_id", "target_type", "target_id", name="uq_likes_user_target"),
        # 索引：快速查找某个对象的点赞情况
        Index("idx_likes_user_target_type", "user_id", "target_type"),
        Index("idx_likes_target_type_id", "target_type", "target_id"),
        Index("idx_likes_created_at", "created_at"),
    )
```



### 数据表关联图



2025.12.1

评论表设定补充

分级评论设计规则：

一级：`parent_id is NULL` 且 `root_id = cid`

二级：`parent_id = root_id`

三级及以上：`parent_id != root_id` 且 `parent_id is not NULL`

这样的好处是任何楼中楼对话，都可以通过以下命令一次性把整组对话拉出来

```sql
SELECT * FROM comments WHERE root_id = :root_cid
```

